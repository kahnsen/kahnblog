<!DOCTYPE html>
<html>
    <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" >
    <title>
        
        ASM全解析 · Kahn&#39;s blogs
        
    </title>
    <link rel="icon" href= /kahnblog/avatar/Totoro.jpeg>
    <!-- 提前加载place holder  -->
    <style>
        @font-face {
            font-family: 'Oswald-Regular';
            src: url('/kahnblog/font/Oswald-Regular.ttf');
        }
        @font-face {
            font-family: 'Source Sans Pro';
            src: url('/kahnblog/font/Source Sans Pro.woff'),
            url('/kahnblog/font/Source Sans Pro.woff2');
            font-weight: normal;
            font-style: normal;
        }
        @font-face {
            font-family: 'Source Code Pro';
            src: url('/kahnblog/font/SourceCodePro-Regular.ttf.woff'),
            url('/kahnblog/font/SourceCodePro-Regular.ttf.woff2');
            font-weight: normal;
            font-style: normal;
        }
        
        
        .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0px;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2s ease-out 0s 1;
        }
        @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        99% {
            transform: translate3d(0, 0, 0);
        }
        99.1% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(-226px, 0, 0);
        }
    }
    </style>
    <link rel="stylesheet" href="/kahnblog/css/style.css">
    <script src="//cdn.staticfile.org/jquery/3.2.1/jquery.min.js" defer></script>
    
    <script src="/kahnblog/scripts/main.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>
    
        <body class="post-body">
    
    
<header class="header">

    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/kahnblog/" >Kahn&#39;s blogs</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">ASM全解析</a>
            </div>
    </div>
    
    <a class="home-link" href=/kahnblog/>Kahn's blogs</a>
</header>
    <div class="wrapper">
        <div class="site-intro">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
    
    <div class="site-intro-img" style="background-image: url(/kahnblog/intro/post-bg.jpg)"></div>
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            ASM全解析
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
        </p>
        <!-- 404 -->
        
        <!-- 文章页meta -->
        
            <!-- 文章页标签  -->
            
            <div class="post-intro-meta">
                <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                <span class="post-intro-time">2017/11/29</span>
            </div>
            <!-- 

<div class="post-share iconfont-archer">
    <ul class="share-box" data-href = "/kahnblog/2017/11/29/ASM全解析/" data-title = "ASM全解析" >
        <li class="to-weibo">分享到微博</li>
        <li class="to-wechat">分享到微信</li>
        <li class="to-qq">分享到QQ</li>
        <li class="to-twitter">分享到twitter</li>
    </ul>
</div> -->
        
    </div>
</div>
        <div class="container">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>不知道为啥，公司刮起一阵AOP编程的风暴，Java体系很老的技术竟然在Android里面迎来了新生。可能是因为App越做越大需要用到？ASM是AOP编程的一种实现方式，它可以用编程的方法改变类字节码。一般ASM主要用来做AOP，和mock测试。当然了，你要是用ASM来直接写代码，写class，谁也拉不长你，吹不扁你。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>具体的概念就不多说了，网上多的是。说下我自己的理解。现在我们接触到的编程模式大概分为，<em>面向过程</em>，<em>面向对象</em>。AOP是<em>面向切面</em>，可以看做是特定功能对面向对象编程的一种补充。此外还有结构化编程（面向对象），和函数式编程。各有好处。</p>
<p>前面说了，AOP是面向对象的补充。</p>
<h4 id="讲一个故事"><a href="#讲一个故事" class="headerlink" title="讲一个故事"></a>讲一个故事</h4><p>既然是面向对象，对象是什么？一个个封装好的个体，桌子，板凳，大舅二舅都是对象，这些封装好的个体还有各自的继承关系，他大舅他二舅都是他舅，高桌子低板凳都是木头。对象中可能还持有别的对象，就形成了关联关系。这些继承和关联关系构成了真实世界。真实世界映射到软件中，就是一个面向对象的软件系统。大舅二舅家都有桌子板凳，桌子板凳都会脏，用之前要擦一下。</p>
<p>问题来了，刚买回来桌子板凳的时候，都是新的干净的，没考虑到它会脏啊？这个时候，传统的做法就是让舅舅（大舅二舅的父类）用桌子板凳的时候，要擦一下。但是这个时候你软件系统里可能还有七大姑八大姨，你可能要想了，那就抽象出一个亲戚类，然后写一个坐板凳的方法，里面写上擦板凳，然后让所有亲戚去实现这个坐板凳方法，再在实现中调用父类的坐板凳。这样下去：越来越复杂。</p>
<p>这时候，AOP就出现了，它犹如上帝之手，用直接传功，灵魂注入的方式，让所有亲戚坐板凳之前，都要擦板凳。你的亲戚们什么都没改变，莫名其妙的坐之前都会先擦一下。</p>
<h4 id="实际的应用场景"><a href="#实际的应用场景" class="headerlink" title="实际的应用场景"></a>实际的应用场景</h4><p>当然了，我们大部分用AOP的场景都不是用来做业务功能的（坐板凳属于业务功能）。</p>
<blockquote>
<p>几个典型的AOP场景</p>
<blockquote>
<ol>
<li>打Log</li>
<li>性能监控</li>
<li>后台服务器的数据库连接和事务管理。解释：一个请求过来，被AOP拦截后，然后打开一个sql的事务。在返回的时候，事务提交或者回滚。这样做的好处是，所有的请求都支持了事务，不用每次都写什么beginTransaction，commit。</li>
<li>安全性检查</li>
<li>埋点打桩</li>
</ol>
</blockquote>
</blockquote>
<h2 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h2><p>惯例不废话，先分享几篇好的博客<br><a href="http://www.timguan.net/2017/03/24/%E5%AD%97%E8%8A%82%E7%A0%81%E5%8F%8AASM%E4%BD%BF%E7%94%A8/" target="_blank" rel="external">字节码及ASM使用</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-asm30/" target="_blank" rel="external">AOP 的利器：ASM 3.0 介绍</a><br><a href="http://www.jianshu.com/p/760229bfe18a" target="_blank" rel="external">ASM Bytecode Framework探索与使用</a><br><a href="http://www.jianshu.com/p/9f09a0c21542" target="_blank" rel="external">JVM指令</a><br><a href="http://asm.ow2.org/doc/tutorial-asm-2.0.html" target="_blank" rel="external">Introduction to the ASM 2.0 Bytecode Framework(官方)</a><br><a href="http://download.forge.objectweb.org/asm/asm4-guide.pdf" target="_blank" rel="external">ASM 4.0 A Java bytecode engineering library(官方)</a><br><a href="https://my.oschina.net/u/1166271/blog/162796" target="_blank" rel="external">深入字节码 – 使用 ASM 实现 AOP(系列文章，个人感觉很好！)</a></p>
<p>ASM只有百十来kb，用法却是千变万化，毕竟是可以直接改字节的东东。</p>
<p>ASM解析字节码采用访问者模式，它把对字节码的访问解析成很多事件（node），然后顺序的交给访问者（visitor），我们只需要处理visitor给我们提供的回调就可以了。这是修改一个现有类的方式。如果想新建一个类class，则需要你按照它提供的顺序做按部就班的做一些事情，新建比修改难的多，这里的难体现在对字节码的了解程度上。</p>
<p><img src="http://asm.ow2.org/images/reader-sequence2.gif" alt="官方解析时序图"></p>
<p>上面的时序图很重要，它完全说明了asm解析class字节码的流程。</p>
<h3 id="Api"><a href="#Api" class="headerlink" title="Api"></a>Api</h3><p>ClassReader和ClassVisitor。</p>
<h4 id="ClassReader"><a href="#ClassReader" class="headerlink" title="ClassReader"></a>ClassReader</h4><p>顾名思义，这玩意可以读取一个class文件。看下它的api</p>
<p>ClassReader(byte[] b)<br>ClassReader(byte[] b, int off, int len)<br>ClassReader(InputStream is)<br>ClassReader(String name)  </p>
<p>很明显了，新建这玩意需要字节数组，或者流和文件名。那么就是一个类的字节码文件的字节数组或者流和文件名对吗？</p>
<p>回看上面的时序图，解析是从accept开始的，接收的参数是一个ClassVisitor，这就是典型的访问者模式了。回看上面的时序图，整个访问流程也是accept方法开始走的，从时序图一路看下来，都是以访问者模式去调用了ClassVisitor中的方法。ClassVisitor中又细化了几个子Visitor，分别是annotationvisitor，fieldvisitor，methodvisitor。</p>
<p>ClassReader就不深究了，里面的方法也不多，它最大的意义在于<em>读取字节码，然后启动整个流程</em>，后面怎样处理就交给了ClassVisitor</p>
<h4 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h4><p>真正能访问各种visit的东西。它以回调的方式给于我们处理字节码各个环节的机会。ClassReader以访问者模式去调用ClassVisitor，而ClassVisitor内部是以职责链模式来处理的(还记得Android中的touch事件传递吗？return true|false控制整个流程)。意思就是说，一个ClassVisitor可以持有另一个ClassVisitor对象，一路持有下去，而访问时，也会逐一挨个访问。ASM给我们内置了几个ClassVisitor，都是它的子类，需要特别关注一下的是ClassWriter，它如果再ClassVisitor职责链中的一环，在accept完成后，ClassWriter可以调用toByteArray获取被修改后的字节码字节数组，可以随意的处理它。看下ClassVisitor的方法</p>
<p><img src="ClassVisitorMethod.png" alt="ClassVisitorMethod.png"></p>
<p>全是以visit开头的方法，需要重点关注的是：visit(), visitAnnotation，visitField，visitMethod，visitEnd。</p>
<p>见名知意，并且api上给出了每个方法的解释。重点说下visit，api上解释是这样的，Visits the header of the class.那么什么是一个class的header呢？官方说明的开头就给出了解释，内容太多就不复制过来了。大概就是说，类的声明信息，包括集成，实现，泛型等等。这个方法也是访问一个类最首先访问到的方法！别的方法就不解释了，开头介绍的<a href="https://my.oschina.net/u/1166271/blog/162796" target="_blank" rel="external">深入字节码 – 使用 ASM 实现 AOP(系列文章，个人感觉很好！)</a>里面有详细描述。</p>
<p>注意！ClassVisitor是处理类级别的回调，不涉及到具体的东西。可以看到，visitAnnotation，visitField，visitMethod，这三个方法都是带返回值的！也就是我们开头说的子visit，用于处理一些更细节的东西。比如，visitMethod方法的返回值是一个MethodVisitor对象，这个MethodVisitor对象就是用于处理这个方法更细节的东西，比如：注解，代码，泛型等等。我们可以创建自己的MethodVisitor，处理一些自己的东西，然后返回。如果什么也不做，直接super.visitMethod(access, name, desc, signature, exceptions)。如果你return null。对不起，相当于略过了这个方法。asm不会扫描这个方法。</p>
<p><strong>请注意：这几个子visit和ClassVisitor并无继承关系</strong>。</p>
<p>在ClassVisitor的方法里面，你就可以随便弄了，我们一般的开发模式是生成目标类的子类后，扩展你需要的方法。在调用的时候，使用反射取出强化过的类对象，如果有，返回回去使用。当然你也可以直接改目标类的class。</p>
<p>一般情况下，都是修改类的class，进行一下插桩操作。</p>
<h4 id="总结流程"><a href="#总结流程" class="headerlink" title="总结流程"></a>总结流程</h4><p>其实ASM只是一个很小的工具包，大致的调用概念就是上面说的。<strong>ClassReader加载字节码文件–&gt;accept方法启动访问者模式–&gt;把class文件拆分成各种visit事件，把拆分的事件循环遍历ClassVisitor中的各种visit方法（ClassVisitor类采用职责链循环递归）–&gt;在ClassVisitor中如遇到visitField，visitMethod等，才用更细化的FieldVisitor等等继续visit–&gt;整个流程完毕</strong></p>
<p>如果没有看文章头部推荐的博客，第一次接触asm，可能说完上面的，还是对流程有点模糊，这时候必须要<strong><em>上代码</em></strong>。</p>
<h4 id="ClassReader遍历ClassVisitor的伪代码"><a href="#ClassReader遍历ClassVisitor的伪代码" class="headerlink" title="ClassReader遍历ClassVisitor的伪代码"></a>ClassReader遍历ClassVisitor的伪代码</h4><p>首先先看一个类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.kahn.test.asm.bean;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String name;</div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用ClassReader加载该类的字节码文件后，会把字节码拆分成各种visit事件，它有多少事件呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, <span class="string">"com/kahn/test/asm/bean/Person"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">cw.visitSource(<span class="string">"Person.java"</span>, <span class="keyword">null</span>);</div><div class="line"></div><div class="line">&#123;</div><div class="line">fv = cw.visitField(ACC_PRIVATE, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">fv.visitEnd();</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">mv.visitCode();</div><div class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</div><div class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</div><div class="line">mv.visitInsn(RETURN);</div><div class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">mv.visitEnd();</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"getName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">mv.visitCode();</div><div class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</div><div class="line">mv.visitFieldInsn(GETFIELD, <span class="string">"com/kahn/test/asm/bean/Person"</span>, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</div><div class="line">mv.visitInsn(ARETURN);</div><div class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">mv.visitEnd();</div><div class="line">&#125;</div><div class="line">cw.visitEnd();</div></pre></td></tr></table></figure>
<p><strong>该代码由工具生成，文章结束有介绍</strong></p>
<p>以上是该类会触发的所有事件，如果想用asm代码直接生成class文件可以用上面代码生成Person.class，下面ClassReader的<strong>accept伪代码</strong>。下面主要展示Method调用过程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">类<span class="function">ClassReader</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(ClassVistor cw)</span> &#123;</div><div class="line"></div><div class="line">	读取字节码基本信息，常量池等等;</div><div class="line">	...</div><div class="line">	cw.visit(xxx);</div><div class="line">	</div><div class="line">	循环注解信息</div><div class="line">	...</div><div class="line">	</div><div class="line">	循环字段信息</div><div class="line">	...</div><div class="line">	</div><div class="line">	</div><div class="line">	<span class="keyword">for</span>(方法个数) &#123;</div><div class="line">		解析方法基本信息</div><div class="line">		MethodVisitor mv = cw.visitMethod(方法信息基本信息);</div><div class="line">		</div><div class="line">		<span class="keyword">if</span>(mv != <span class="keyword">null</span>) &#123;</div><div class="line">			...一些七七八八注解之类的回调</div><div class="line">			mv.visitCode();</div><div class="line">			<span class="comment">//下面进入方法体解析，一些具体的方法</span></div><div class="line">			解析方法详细信息</div><div class="line">			<span class="keyword">if</span>(aaa != <span class="keyword">null</span>)&#123;</div><div class="line">				mv.visitAaa();</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">if</span>(bbb != <span class="keyword">null</span>)&#123;</div><div class="line">				mv.visitBbb();</div><div class="line">			&#125;</div><div class="line">			</div><div class="line">			mv.visitInsn(ARETURN);</div><div class="line">			<span class="comment">//方法结束</span></div><div class="line">			mv.visitEnd();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	...</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>就是这样，整个Class文件被accept遍历了一遍，再看下ClassVistor的visitMethod  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></div><div class="line">        String signature, String[] exceptions) &#123;</div><div class="line">    <span class="keyword">if</span> (cv != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> cv.visitMethod(access, name, desc, signature, exceptions);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的cv也是一个ClassVistor，是由创建一个ClassVisitor的时候传入的，这样就形成了职责链，一路调用下去。注意！职责链是有顺序的，采用了堆栈模型，被accept的ClassVisitor A最先调用，然后调用A持有的B。<strong>重点来了请注意，我们应该把ClassWriter放在调用链的最后一环才能得到正确的class文件。</strong></p>
<p><strong>源代码跟上面的伪代码实现差不多，再回到开头我们说的，如果想忽略哪个方法，可以在自己实现的ClassVisitor里面的visitMethod方法里面返回null，上面的accept就给出了为什么能忽略该方法的原因。因为返回了null，accpte内部代码没有拿到MethodVisitor，就不会去解析该方法</strong></p>
<p>再来看MethodVisitor的visitCode</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (mv != <span class="keyword">null</span>) &#123;</div><div class="line">        mv.visitCode();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>MethodVisitor中的其他visit方法也都是这么实现的，调用了内部持有的MethodVisitor。<strong>所以！MethodVisitor也是一条职责链，同样的FieldVisitor，AnnocationVisitor也是。</strong></p>
<p>到了这里，整个ClassReader加载字节码流程有没有更清楚一点了呢？</p>
<p>现在要用起来了，老规矩，上代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</div><div class="line">	ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"com.kahn.test.asm.bean.Person"</span>);</div><div class="line">	classReader.accept(<span class="keyword">new</span> PrintVisitor(), ClassReader.SKIP_DEBUG);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码很简单，创建一个ClassReader，读取类com.kahn.test.asm.bean.Person的字节码，然后开始accept，传入一个我们自己的PrintVisitor。来看下PrintVisitor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintVisitor</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(Opcodes.ASM5);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</div><div class="line"></div><div class="line">		System.out.println(access + <span class="string">", "</span> + name + <span class="string">", "</span> + signature + <span class="string">", "</span> + superName + <span class="string">", "</span> + interfaces);</div><div class="line">		<span class="keyword">super</span>.visit(version, access, name + <span class="string">"_temp"</span>, signature, name, interfaces);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> AnnotationVisitor <span class="title">visitAnnotation</span><span class="params">(String desc, <span class="keyword">boolean</span> visible)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.visitAnnotation(desc, visible);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, Object value)</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		</div><div class="line">		System.out.println(access + <span class="string">", "</span> + name + <span class="string">", "</span> + signature );</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.visitField(access, name, desc, signature, value);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</div><div class="line">		System.out.println(access + <span class="string">", "</span> + name + <span class="string">", "</span> + signature );</div><div class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.visitMethod(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">		<span class="keyword">super</span>.visitEnd();</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>很简单的ClassVisitor子类，这里我没有使用ClassVisitor(int api, ClassVisitor cv)这个构造函数，也就是说我们这个PrintVisitor内部没有再持有一个ClassVisitor对象，它是职责链顶端也是末端，就它自己。</p>
<p>这里简单的复写了它的几个方法，全部是调用的父类的，调用之前打印了一下日志。</p>
<p>运行代码后，结果为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="number">33</span>, com/kahn/test/asm/bean/Person, <span class="keyword">null</span>, java/lang/Object, [Ljava.lang.String;@<span class="number">59f</span>95c5d</div><div class="line"><span class="number">2</span>, name, <span class="keyword">null</span></div><div class="line"><span class="number">2</span>, age, <span class="keyword">null</span></div><div class="line"><span class="number">1</span>, &lt;init&gt;, <span class="keyword">null</span></div><div class="line"><span class="number">1</span>, getName, <span class="keyword">null</span></div><div class="line"><span class="number">1</span>, setName, <span class="keyword">null</span></div><div class="line"><span class="number">1</span>, getAge, <span class="keyword">null</span></div><div class="line"><span class="number">1</span>, setAge, <span class="keyword">null</span></div></pre></td></tr></table></figure>
<p>可以看到ClassReader扫描了这个类的基本信息，还能看到，它先访问了visit方法，然后是visitField，然后是visitMethod(先输出了name，age，后输出<init>，getName…)。</init></p>
<p>这里都是直接调用的super.xxxx 继续使用父类的。父类的(ClassVisitor的)方法，我们刚刚已经看过了，都是调用内部持有的ClassVisitor，这里我们没有持有内部的ClassVisitor，所以这里的super.xxxx其实什么也做。</p>
<p><strong>同理，调用在visitMethod方法中这样写到： return super.visitMethod(access, name, desc, signature,  exceptions); 那么父类内部的ClassVisitor为空，这时我们能猜到，其实这边返回的是一个null。也就是说：在本例中，accept并不会去扫描方法或者字段等等的具体信息，因为它们对应的方法返回了一个null。这也是ASM延迟加载机制，只有在被用到，才会扫描</strong></p>
<p>好了，这么做貌似没什么用，我们来加强一下例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException, InstantiationException, IllegalAccessException </span>&#123;</div><div class="line">	ClassReader classReader = <span class="keyword">new</span> ClassReader(<span class="string">"com.kahn.test.asm.bean.Person"</span>);</div><div class="line">	ClassWriter cw = <span class="keyword">new</span> ClassWriter(ClassWriter.COMPUTE_MAXS);</div><div class="line">	classReader.accept(<span class="keyword">new</span> PrintVisitor(cw), ClassReader.SKIP_DEBUG);</div><div class="line">	OutputStream outputStream = <span class="keyword">new</span> FileOutputStream(<span class="string">"Person.class"</span>);</div><div class="line">	outputStream.write(cw.toByteArray());</div><div class="line">	outputStream.close();	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ClassVisitor链条上加了一个ClassWriter，把这个ClassWriter对象赋值给了PrintVisitor，在accept结束后，使用cw.toByteArray()得到新的字节码数组，写成本地文件存储</p>
<p>看下PrintVisitor</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">PrintVisitor</span><span class="params">(ClassVisitor cv)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>(Opcodes.ASM5, cv);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc, String signature, String[] exceptions)</span> </span>&#123;</div><div class="line">		System.out.println(access + <span class="string">", "</span> + name + <span class="string">", "</span> + signature );</div><div class="line">		 <span class="keyword">if</span> (<span class="string">"getName"</span>.equals(name)) &#123;</div><div class="line"></div><div class="line">			mvTemp = <span class="keyword">new</span> MethodVisitor(Opcodes.ASM5, <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions)) &#123;</div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</div><div class="line">					<span class="keyword">super</span>.visitCode();</div><div class="line">					visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</div><div class="line">					visitLdcInsn(<span class="string">"insert ok!"</span>);</div><div class="line">					visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>,</div><div class="line">							<span class="keyword">false</span>);</div><div class="line">				&#125;</div><div class="line"></div><div class="line">				<span class="meta">@Override</span></div><div class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitMaxs</span><span class="params">(<span class="keyword">int</span> maxStack, <span class="keyword">int</span> maxLocals)</span> </span>&#123;</div><div class="line">					<span class="keyword">super</span>.visitMaxs(<span class="number">2</span>, <span class="number">1</span>);</div><div class="line">				&#125;</div><div class="line">				</div><div class="line">			&#125;;</div><div class="line">		&#125;</div><div class="line">		</div><div class="line">		<span class="keyword">else</span> &#123;</div><div class="line">			mvTemp = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> mvTemp;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	...</div></pre></td></tr></table></figure>
<p>我改造了一下visitMethod方法，如果遍历到的这个方法名是getName，我就自己实现一个MethodVisitor返回，如果是别的方法，使用父类的super.visitMethod返回。<strong>请注意！这回这里的super.visitMethod不再是毫无用处了，因为PrintVisitor不再是职责链的最后一环，它内部还持有一个ClassWriter，这里调用super.visitMethod其实是调用了ClassWriter的visitMethod，ClassWriter的visit方法全是往内存里圧栈的操作，这很重要！以为有了ClassWriter我们才能输出有效的class文件</strong></p>
<p>看下我们自己实现的MethodVisitor，在MethodVisitor构造函数中传入了super.visitMethod返回的MethodVisitor，OK，MethodVisitor也形成了职责链，我们自己的MethodVisitor再调用super.xxx方法时，其实是调用了内部持有的MethodVisitor。这个内部持有的MethodVisitor其实也是刚刚通过super.visitMethod生成的。它是什么呢？它是ClassWriter的visitMethod方法生成的一个MethodWriter对象，这个MethodWriter是MethodVisitor的子类。</p>
<p>回到我们自己的匿名内部MethodVisitor。里面只实现了两个方法，visitCode和visitMaxs。visitCode是刚进入到代码中触发的，而visitMaxs则表示该方法需要的内存堆栈。</p>
<p>先看下visitCode，里面先调用了super.visitCode();这个是必须的！因为要调用职责链下层，MethodWriter的visitCode。紧跟着调用了三句代码，全都是MethodVisitor自己的未被覆盖的代码，这三句代码也同样都会调用MethodWriter的相应方法。</p>
<p>我们知道visitCode是进入代码的意思。那么后面三句是什么意思呢？不要慌，如果看过顶部推荐的博客就已经知道了，没看也没关系，楼主重复造下轮子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">visitFieldInsn(Opcodes.GETSTATIC, <span class="string">"java/lang/System"</span>, <span class="string">"out"</span>, <span class="string">"Ljava/io/PrintStream;"</span>);</div><div class="line">visitLdcInsn(<span class="string">"insert ok!"</span>);</div><div class="line">visitMethodInsn(Opcodes.INVOKEVIRTUAL, <span class="string">"java/io/PrintStream"</span>, <span class="string">"println"</span>, <span class="string">"(Ljava/lang/String;)V"</span>,<span class="keyword">false</span>);</div></pre></td></tr></table></figure>
<p>这三句的意思，1，获取System的静态变量out。2，往堆栈中压入一个字符串”insert ok!”。3，调用PrintStream的println方法，联系上下文，现在堆栈中第一位是一个PrintStream的变量out，第二位是一个字符串”insert ok!”，那么这里调用PrintStream的println方法其实就相当于调用System.out.println(“insert ok!”)。</p>
<p><strong>又是一波重点来袭！因为这些方法都是调用的MethodWriter的相应方法，MethodWriter是什么？前面刚刚讲过，要注意！MethodWriter会把这些操作压入堆栈</strong>，那么经过刚刚那么一折腾，其实就是，在gatName方法刚入代码后，压入一套System.out.println(“insert ok!”)的字节码指令。</p>
<p>那么重写的visitMaxs是什么意思？super.visitMaxs(2, 1)？因为你这个方法本来的字节码应该调用visitMaxs(1, 1)，如果不重写其实默认的就是visitMaxs(1, 1)，但是我们修改了字节码，多在堆栈里压了一些东西，所以要改下（测试发现，没重写也能正常运行，可能是ASM有什么特殊处理吧）。</p>
<p>ok！我们重新运行一下。用JD-GUI打开生成的Person.class文件（不要打开原始的，要打开我们新生成的）。可以看到getName里面多了一句System.out.println(“insert ok!”)。</p>
<p>利用这个特性，我们就能做很多事情了。</p>
<p>如果你是android开发，直接修改class文件是一件很好的事情，可以无损注入代码，并且这些操作都是在编译期进行的，对代码执行效率没有任何影响。</p>
<p>如果你是后台开发，最好的做法是生成一个该类的子类class文件，然后使用反射把这个生成的子类对象反射出来返回给要使用的人，这就形成了代理模式。这样做对原始的class文件也没有入侵了，会更优雅一点。但是在android中，能少用反射还是尽量少用。</p>
<h5 id="下面我们看下怎么生成该类的子类。"><a href="#下面我们看下怎么生成该类的子类。" class="headerlink" title="下面我们看下怎么生成该类的子类。"></a>下面我们看下怎么生成该类的子类。</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature, String superName, String[] interfaces)</span> </span>&#123;</div><div class="line"></div><div class="line">	System.out.println(access + <span class="string">", "</span> + name + <span class="string">", "</span> + signature + <span class="string">", "</span> + superName + <span class="string">", "</span> + interfaces);</div><div class="line">	<span class="keyword">super</span>.visit(version, access, name + <span class="string">"_temp"</span>, signature, name, interfaces);</div><div class="line">	&#123;</div><div class="line">		MethodVisitor mv = <span class="keyword">super</span>.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">		mv.visitCode();</div><div class="line">		mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</div><div class="line">		mv.visitMethodInsn(Opcodes.INVOKESPECIAL, name, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</div><div class="line">		mv.visitInsn(Opcodes.RETURN);</div><div class="line">		mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">		mv.visitEnd();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看下新修改的visit方法，这里mv其实是ClassWriter返回的MethodWriter对象，前面强调了多次！请悉知！！！后面的super.xxx也都是调用ClassWriter内的方法，重要的事情要多说。<br>visit方法的调用时机为刚解析这个类的header时。类header的概念前面也有说过。super.visit(version, access, name + “_temp”, signature, name, interfaces)，这里的变化是，把类名该为了类名加_temp，父类的名称改为本来类的名称，这时，ClassWriter内持有的class字节信息就变为了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person_temp</span> <span class="keyword">extends</span> <span class="title">Person</span></span></div></pre></td></tr></table></figure>
<p>再来看下面的代码，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">MethodVisitor mv = <span class="keyword">super</span>.visitMethod(Opcodes.ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">mv.visitCode();</div><div class="line">mv.visitVarInsn(Opcodes.ALOAD, <span class="number">0</span>);</div><div class="line">mv.visitMethodInsn(Opcodes.INVOKESPECIAL, name, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</div><div class="line">mv.visitInsn(Opcodes.RETURN);</div><div class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">mv.visitEnd();</div></pre></td></tr></table></figure>
<p>上面的全部代码都表示往字节码堆栈中压入生成了一个构造方法(<init>表示构造方法)</init></p>
<p>ok，如果你不处理visitMethod方法，到最后你新的字节码堆栈中会有两个构造方法，一个是Person的一个是Person_temp，这样的字节码必然是错误的。so~~要去visitMethod中把从扫描Person类得来的构造方法忽略掉。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">"&lt;init&gt;"</span>.equals(name)) &#123;</div><div class="line">	mvTemp = <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在visitMethod中，忽略从扫描Person类得来的构造方法。</p>
<p>现在去运行程序，然后反射出该子类对象，再调用getName，看看我们的子类生成计划是否成功</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Object o = Class.forName(<span class="string">"com.kahn.test.asm.bean.Person_temp"</span>).newInstance();</div><div class="line">Person p = (Person) o;</div><div class="line">System.out.println(p.getName());</div></pre></td></tr></table></figure>
<p>运行后输出</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">insert ok!</div><div class="line">Exception in thread "main" java.lang.IllegalAccessError: tried to access field com.kahn.test.asm.bean.Person.age from class com.kahn.test.asm.bean.Person_temp</div><div class="line">	at com.kahn.test.asm.bean.Person_temp.getAge(Unknown Source)</div><div class="line">	at com.kahn.test.asm.TestOnMain.main(TestOnMain.java:51)</div></pre></td></tr></table></figure>
<p>纳尼?what’s wrong?这就尴尬了，插入的语句打印出来了，自带的代码反而报错，自带的代码是什么呢？return name;异常提示，错误的访问了Person.age from Person_temp。意思大概就是说，你在Person_temp里面调用到了父类的同名私有变量。日了狗，怎么能访问到父类的呢？父类里有一个private String name. 我子类里面也有一个private String name，使用JD-GUI打开生成class，发现代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">	System.out.println(<span class="string">"insert ok!!"</span>);</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我靠？这没错啊，this.name呀？百思不得骑姐。</p>
<p>回去看开Person.class生成的asm代码，也就是文章最前面的事件分析的地方。</p>
<p>来看下getName的所有visit事件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"getName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">mv.visitCode();</div><div class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</div><div class="line">mv.visitFieldInsn(GETFIELD, <span class="string">"com/kahn/test/asm/bean/Person"</span>, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</div><div class="line">mv.visitInsn(ARETURN);</div><div class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">mv.visitEnd();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意到这句没有？mv.visitFieldInsn(GETFIELD, “com/kahn/test/asm/bean/Person”, “name”, “Ljava/lang/String;”)。在Person类中，取出Person类的name字段。</p>
<p>这样一来就清楚了，我们的Person_temp是从Person扫描得来，所以Person_temp的字节码文件中，getName里面取出的是Person的name字段。坑爹的是JD-GUI竟然能解析。找到解决办法了，让我们的新类Person_temp的getName方法使用字节的name字段就可以了。</p>
<p>在我们自己的MethodVisitor里面再多复写一个方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFieldInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc)</span> </span>&#123;</div><div class="line">	<span class="comment">// TODO Auto-generated method stub</span></div><div class="line">	<span class="keyword">super</span>.visitFieldInsn(opcode, owner+<span class="string">"_temp"</span>, name, desc);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把第二个参数的Person换成Person_temp。</p>
<p>在运行一下，大功告成</p>
<h4 id="直接使用asm生成class"><a href="#直接使用asm生成class" class="headerlink" title="直接使用asm生成class"></a>直接使用asm生成class</h4><p>前面都是以ClassReader的accept为起点，扫描一个现有的类。那么我们怎么凭空编造一个类呢？其实看完上面的文章，你应该已经有答案了。生成新的字节码跟ClassReader一点关系也没有，完全是基于ClassWriter。</p>
<p>开篇的事件演示代码就说过了，这些代码就能生成一个Person类的字节码：<br>再次copy该代码！！！！！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">cw.visit(V1_7, ACC_PUBLIC + ACC_SUPER, <span class="string">"com/kahn/test/asm/bean/Person"</span>, <span class="keyword">null</span>, <span class="string">"java/lang/Object"</span>, <span class="keyword">null</span>);</div><div class="line">cw.visitSource(<span class="string">"Person.java"</span>, <span class="keyword">null</span>);</div><div class="line">&#123;</div><div class="line">fv = cw.visitField(ACC_PRIVATE, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">fv.visitEnd();</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">mv.visitCode();</div><div class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</div><div class="line">mv.visitMethodInsn(INVOKESPECIAL, <span class="string">"java/lang/Object"</span>, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>, <span class="keyword">false</span>);</div><div class="line">mv.visitInsn(RETURN);</div><div class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">mv.visitEnd();</div><div class="line">&#125;</div><div class="line">&#123;</div><div class="line">mv = cw.visitMethod(ACC_PUBLIC, <span class="string">"getName"</span>, <span class="string">"()Ljava/lang/String;"</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</div><div class="line">mv.visitCode();</div><div class="line">mv.visitVarInsn(ALOAD, <span class="number">0</span>);</div><div class="line">mv.visitFieldInsn(GETFIELD, <span class="string">"com/kahn/test/asm/bean/Person"</span>, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</div><div class="line">mv.visitInsn(ARETURN);</div><div class="line">mv.visitMaxs(<span class="number">1</span>, <span class="number">1</span>);</div><div class="line">mv.visitEnd();</div><div class="line">&#125;</div><div class="line">cw.visitEnd();</div></pre></td></tr></table></figure>
<p>只要你自己新建一个ClassWriter，挨个调用上面的代码。在最后，toByteArray出来字节数组然后保存，或者用类加载器加载都可以。</p>
<p>到这里，字节码的修改和生成都已经说完了。</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>没啥好说的，介绍一下工具吧。</p>
<p>Eclipse上的ASM特供字节码插件BytecodeOutline地址：<a href="http://andrei.gmxhome.de/eclipse/" target="_blank" rel="external">http://andrei.gmxhome.de/eclipse/</a>，也可以使用这个地址，里面有更多关于asm的工具(内含BytecodeOutline)。<a href="http://download.forge.objectweb.org/eclipse-update/" target="_blank" rel="external">http://download.forge.objectweb.org/eclipse-update/</a></p>
<p>安装插件后，把用showview把BytecodeOutline的视图调出来，就可以看到对应类生成的字节码了，点击红色的asm，就可以看到该类生成的asm代码了。所以！！千万不要傻傻的自己拼，没有意义。</p>
<p>ASM生成的一些代码，是调试信息，行号之类的，无关大局可以移除。像下面这样的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Label l0 = <span class="keyword">new</span> Label();</div><div class="line">mv.visitLabel(l0);</div><div class="line">mv.visitLineNumber(<span class="number">10</span>, l0);</div></pre></td></tr></table></figure>
<p>又或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Label l1 = <span class="keyword">new</span> Label();</div><div class="line">mv.visitLabel(l1);</div><div class="line">mv.visitLocalVariable(<span class="string">"this"</span>, <span class="string">"Lcom/kahn/test/asm/bean/Person;"</span>, <span class="keyword">null</span>, l0, l1, <span class="number">0</span>);</div></pre></td></tr></table></figure>
<p>都是可以删除的。我们accept的时候没有扫描到这样的代码，其实是因为我们传了一个SKIP_DEBUG的参数。该工具配置参数里也提供选项可以移除，但是移不干净。</p>
<p>在编写asm代码时的一个技巧是对比原始类和你想要获得的类的asm生成代码，这样就不会出现我之前在子类里面调用父类私有成员变量的问题了。恰好该用具也直接提供了对比两个类的功能。<br><img src="eclipse-plugin_bytecodeoutline.gif" alt="eclipse-plugin_bytecodeoutline"></p>
<h2 id="最后的最后"><a href="#最后的最后" class="headerlink" title="最后的最后"></a>最后的最后</h2><p>使用这个一定注意java版本问题。不要随便升级asm版本和java版本。轻易不要追新，毕竟是黑科技，在一个版本上调通就不错了。能用设计模式，代码解决的尽量用代码解决。切记切记。</p>
<p>我哔哔完了。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>能自己实现一个插件，把一个类的class文件转成ASM代码吗？</p>
<p>思路：上面我们说了ClassReader的accept流程，它会分布的解析字节码然后调用visit。那么反向思考，用ClassWriter按顺序调用visit就可以还原该类。BytecodeOutline生成的asm代码就是这样的。我们怎么才能获取到accept的调用流程呢？</p>
<p>注入！还是注入。既然accept会逐步调用ClassVisitor的visit方法，我们是不是可以在ClassVisitor的所有visit方法前面注入一段代码？输出方法名和所有参数的值。然后使用这个被我们注入过的ClassVisitor去解析我们想要生成代码的类。注入后的ClassVisitor类似这样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2, String paramString1, String paramString2, String paramString3, String[] paramArrayOfString)</span></span></div><div class="line"> &#123;</div><div class="line">   CollectMethodInfo localCollectMethodInfo = <span class="keyword">new</span> CollectMethodInfo(<span class="string">"visit"</span>);</div><div class="line">   localCollectMethodInfo.putParam(Integer.valueOf(paramInt1));</div><div class="line">   localCollectMethodInfo.putParam(Integer.valueOf(paramInt2));</div><div class="line">   localCollectMethodInfo.putParam(paramString1);</div><div class="line">   localCollectMethodInfo.putParam(paramString2);</div><div class="line">   localCollectMethodInfo.putParam(paramString3);</div><div class="line">   localCollectMethodInfo.putParam(paramArrayOfString);</div><div class="line">   localCollectMethodInfo.print();</div><div class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.cv != <span class="keyword">null</span>) &#123;</div><div class="line">     <span class="keyword">this</span>.cv.visit(paramInt1, paramInt2, paramString1, paramString2, paramString3, paramArrayOfString);</div><div class="line">   &#125;</div><div class="line"> &#125;</div></pre></td></tr></table></figure>
<p>上面注的代码为：先把所有参数都存入一个List，然后print出来<br>localCollectMethodInfo.print();会输出这样的日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">visit(<span class="number">51</span>, <span class="number">33</span>, com/kahn/test/asm/bean/Person, <span class="keyword">null</span>, java/lang/Object, [Ljava.lang.String;@<span class="number">78308</span>db1, )</div></pre></td></tr></table></figure>
<p>51和33都是Opcodes的静态字段,值为V1_7, ACC_PUBLIC + ACC_SUPER(ps:ACC_PUBLIC = 0x0001,ACC_SUPER)</p>
<p>ok，整个程序运行下来全部的输出日志</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">visit(<span class="number">51</span>, <span class="number">33</span>, com/kahn/test/asm/bean/Person, <span class="keyword">null</span>, java/lang/Object, [Ljava.lang.String;@<span class="number">78308</span>db1, )</div><div class="line">visitField(<span class="number">2</span>, name, Ljava/lang/String;, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitField(<span class="number">2</span>, age, I, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitMethod(<span class="number">1</span>, &lt;init&gt;, ()V, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitMethod(<span class="number">1</span>, getName, ()Ljava/lang/String;, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitMethod(<span class="number">1</span>, setName, (Ljava/lang/String;)V, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitMethod(<span class="number">1</span>, getAge, ()I, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitMethod(<span class="number">1</span>, setAge, (ILjava/lang/String;Lorg/objectweb/asm/ClassVisitor;Ljava/lang/Runnable;JD[I[JZ)V, <span class="keyword">null</span>, <span class="keyword">null</span>, )</div><div class="line">visitEnd()</div></pre></td></tr></table></figure>
<p>看起来是不是很熟悉？和asm工具生成的工具代码差不多？这只是个简答的例子，还少了很多东西。比如对field，annotation，method的详细visit。但是思路就是这样的，我们这里只注入了ClassVisitor。可以把ASM这一套visitor都注入，比如MethodVisitor。最后得出日志就是asm的代码了。</p>
<p>前面讲的都是插入一段静态的代码，插入静态代码是非常简单的，使用工具查看要生成的asm代码直接copy过去就完事了。但是！这个练习可能会有些不一样。</p>
<p>这个例子的难点在于怎么使用ASM在方法体中取出参数的值。对于一些要检测方法参数的需求，还是有用的。</p>
<p>有空了把这个例子的源代码放上来。</p>

    </article>
    <!-- 前后页  -->
    <ul class="post-pager">
        
            <li class="previous">
                <a href= "/kahnblog/2017/12/05/Annotation-Processing-Tool/" title= Annotation Processing Tool >
                    <span>Previous Post</span>
                    <span>Annotation Processing Tool</span>
                </a>
            </li>
        
        
            <li class="next">
                <a href= "/kahnblog/2017/11/23/Git常用命令备忘/" title= Git常用命令备忘 >
                    <span>Next Post</span>
                    <span>Git常用命令备忘</span>
                </a>
            </li>
        
    </ul>
    <!-- 来必力City版安装代码 -->

    

<!-- City版安装代码已完成 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="emailto:kahn_2009@live.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/kahnsen" class="iconfont-archer github" target="_blank" title="github"></a>
            
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span>
        <span
            id="theme-info">Theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
        <span id="busuanzi_container_site_pv">Welcome, No. <span id="busuanzi_value_site_pv"></span>
        </span>
    </div>
    
</footer>
    </div>
    <div class="back-top">&#xe639;</div>
    <div class="sidebar">
    <div class="sidebar-header">
        <div class="sidebar-category">
            <span class="sidebar-archive-link"><span class="iconfont-archer">&#xe67d;</span>Archive</span>
            <span class="sidebar-tags-link"><span class="iconfont-archer">&#xe610;</span>Tag</span>
        </div>
    </div>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-archive">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-archive"> Total : 25 </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/kahnblog/2023/09/19/记一次AndroidStudio-Git升级/" >记一次AndroidStudio Git升级</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/kahnblog/2023/09/19/Javadoc详解/" >Javadoc详解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/kahnblog/2023/09/19/MacOs自动同步本地Git库到Github/" >MacOs自动同步本地Git库到Github</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/15</span><a class="archive-post-title" href= "/kahnblog/2020/05/15/Git-Commit-Message规范/" >Git Commit Message规范</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2019 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href= "/kahnblog/2019/03/04/学习Dart语言随手笔记/" >学习Dart语言随手笔记</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2018 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href= "/kahnblog/2018/12/28/Dart依赖和搭建Flutter-or-Dart简易私人仓库/" >Dart依赖和搭建Flutter or Dart简易私人仓库</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/20</span><a class="archive-post-title" href= "/kahnblog/2018/07/20/Flutter了解一下？/" >Flutter了解一下？</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/06</span><a class="archive-post-title" href= "/kahnblog/2018/07/06/使用Python创建你自己的CLI工具箱/" >使用Python的Plumbum库创建你自己的CLI工具箱</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span><a class="archive-post-title" href= "/kahnblog/2018/06/29/Python3学习笔记/" >Python3学习笔记</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href= "/kahnblog/2018/05/03/用Android-productFlavors-构建你的多面应用/" >用Android productFlavors 构建你的多面应用 </a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2017 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/05</span><a class="archive-post-title" href= "/kahnblog/2017/12/05/Annotation-Processing-Tool/" >Annotation Processing Tool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/29</span><a class="archive-post-title" href= "/kahnblog/2017/11/29/ASM全解析/" >ASM全解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/23</span><a class="archive-post-title" href= "/kahnblog/2017/11/23/Git常用命令备忘/" >Git常用命令备忘</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/17</span><a class="archive-post-title" href= "/kahnblog/2017/11/17/搭建Jenkins-Git-Gradle持续集成CI打包平台/" >搭建Jenkins+Git+Gradle持续集成CI打包平台</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/30</span><a class="archive-post-title" href= "/kahnblog/2017/10/30/Java-7-and-Java-8特性你有用过吗？一/" >Java 7 and Java 8特性你有用过吗？二</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/kahnblog/2017/09/27/Java-7-and-Java-8特性你有用过吗？/" >Java 7 and Java 8特性你有用过吗？一</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/19</span><a class="archive-post-title" href= "/kahnblog/2017/09/19/Android原生app加载RN界面原理/" >Android原生app加载RN界面过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/kahnblog/2017/09/15/RN环境-Android原生和JS交互/" >RN环境 Android原生和JS交互</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/kahnblog/2017/09/14/Dagger-2-迁移方案和生成代码基本原理/" >Dagger 2 迁移方案和生成代码基本原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/14</span><a class="archive-post-title" href= "/kahnblog/2017/09/14/EventBus3-0源代码全解析/" >EventBus3.0源代码全解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/kahnblog/2017/09/12/Android集成RN/" >现有原生Android应用集成RN（React Native Android）开发环境</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/kahnblog/2017/09/11/你还敢说精通Java吗？/" >你还敢说精通Java吗？</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/kahnblog/2017/09/08/Markdown-Help/" >Markdown Help</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/08</span><a class="archive-post-title" href= "/kahnblog/2017/09/08/开源许可证/" >开源许可证文章整理</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2014 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/11</span><a class="archive-post-title" href= "/kahnblog/2014/06/11/UML复习备忘录/" >UML复习备忘录</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name"><a href= "#">Software</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Android</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">RN</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Java</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Dart</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Flutter</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Git</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Tools</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Reproduced</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Dagger</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Python</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">Python3</a></span>
    
        <span class="sidebar-tag-name"><a href= "#">EventBus</a></span>
    
    </div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #888; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: false
    tags: true</pre>
    </div> 
    <div class="sidebar-tag-list"></div>
</div>
    </div>
</div> 
    <script>
    var jsInfo = {
        root: '/kahnblog/'
    }
</script>
    <!-- 不蒜子  -->
    
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ统计  -->
    
    </div>
    </body>
</html>


